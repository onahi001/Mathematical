# -*- coding: utf-8 -*-
"""newton_raphson.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gw8JcqYERgXSQpnqikpQVo7MlR7xDDOf
"""



"""#   **NEWTON RAPHSON PROGRAMS**

All programs of this notebook are to execute the newton raphson method of numerical solutions to diverse scenarios and equations.


**NEWTON RAPHSON SPECIFIC FUNCTION**

The next block of code is a newton raphson method executed for a specific 1 dimensional equation
"""

import math

# program to carry out Newton's method for a specific function
# x_test = estimated value of x\
# tol = tolerance error
# fun = function of x
# fun_p = derivative of function of x
# x count

def newton_root(x_test, tol, ite):
    x_c = 1

    for a in range (ite):
        fun = 8 - 4.5*(x_test -math.sin(x_test))
        fun_p = -4.5*(1-math.cos(x_test))
        xi = x_test - (fun/fun_p)
        if abs((xi -x_test)/x_test) < tol:
            print ("root of x = " + str(xi))
            break
        else:
            x_test = xi
            print (str(x_c) + " = "+ str(x_test))
            x_c += 1


newton_root(2, 0.0001, 10)

"""## **NEWTON RAPHSON GENERALISED CODE**

The next block of code is a newton raphson function capable of taking any one dimensional equation and some parameters.


**note:** please comment and notify me of any errors seen during run time that breaks the code. all suggestions are welcome
"""

import math
from sympy import *


# program to carry out Newton's method for any one dimensional function
# x_test = estimated value of x
# ite = Maximum Number of Iteration
# tol = maximum error
# function= function of x
# fun_p = derivative of function of x
# x count

def newton_gen_root(x_test, tol, ite, function):
    x_c = 1

    for a in range (ite):
        try:
          x = symbols("x")
          subs = {x:x_test}     #creates a dict. of variable and value

          fun_1 = expand(fun, x)          # aims to expand polynomial functions
          function = simplify(fun_1).evalf(subs = subs) # substitutes value for the equation and solves it

          fun_prime = diff(fun).evalf(subs = subs)

          if fun_prime == 0:
            print("Enter valid mathematical function. If trigonometry present, use brackets around variables.")

        except:
          print ("Something is wrong simplyfing function")

        xi = x_test - (function/fun_prime)
        if abs((xi -x_test)/x_test) < tol:
            print ("root of x = " + str(xi))
            break

        else:
            x_test = xi
            print (str(x_c) + " = "+ str(x_test))
            x_c += 1

try:
  x_test = float(input("Enter an Estimated value for x: "))
  ite = int(input("Enter the maximum number of iteration: "))
  tol = float (input("Enter the maximum error: "))
  fun = input("Enter the function using x for the variables: \n")
except:
  print("Enter a Number. make sure iteration is an integer: ")

try:
  newton_gen_root (x_test, tol, ite, fun)
except TypeError:
  print("cannot compute the value of estimated error anymore")
except UnboundLocalError:
  print("check you entered the equation correctly.\n common errors include omission of * when multiplying coefficients")

"""**NEWTON RAPHSON FOR 2-DIMENSIONAL EQUATIONS**

The next block of program is a function to calculate any 2 dimensional non linear equation using newton raphson method.

**note:** please comment and notify me of any errors seen during run time that breaks the code. all suggestions are welcome
"""

# program to perform newton raphson method on a 2 dimensional non linear system of equation
# f_1 represents the first function and f_2 reprsents the second funtion

import numpy as np
import math
from sympy import *


try:
  x_test = float(input("Enter an Estimated value for x: "))
  y_test = float(input("Enter an Estimated value for y: "))
  ite = int(input("Enter the maximum number of iteration: "))
  tol = float (input("Enter the maximum error: "))
  f_1 = input("Enter the first function using x and y for the variables:")
  f_2 = input("Enter the second function using x and y for the variables:")
except:
  print("Enter a Number. make sure iteration is an integer: ")


x, y = symbols("x y")
subs = {x:x_test, y:y_test}


# function to calculate the jacobian matrix

def jacob_func(f_1, f_2):
  #x1, x2, y1, y2 = symbols("x1 x2 y1 y2")
  # finding the partial derivatives of the function

  f_1_x = diff(f_1, x).evalf(subs = subs)
  f_2_x = diff(f_2, x).evalf(subs = subs)
  f_1_y = diff(f_1, y).evalf(subs = subs)
  f_2_y = diff(f_2, y).evalf(subs = subs)

  jab = np.array([
      [f_1_x, f_1_y],
      [f_2_x, f_2_y]
  ])

  return jab


# creating a null matrix of shape 2 x 2
mat_null = np.array([
    [0.0, 0.0],
    [0.0, 0.0]
])

# defining a function to calculate the inverse of a matrix
def mat_inv (mat):

  det = (mat[0][0] * mat[1][1]) - (mat[0][1] * mat[1][0]) # determinant of the matrix
  mat_null[0][0] = mat[1][1]
  mat_null[1][1] = mat[0][0]
  mat_null[0][1] = - mat[0][1]
  mat_null[1][0] = - mat[1][0]

  mat_inverse = (1/det) * mat_null
  return mat_inverse

def newton_raphson_2d(f_1, f_2, x_test, y_test, tol, ite):
  # counting the number of iterations
  x_c = 1


  for a in range(ite):

    # Evaluating the functions

    func_1 = expand(f_1).evalf(subs = subs)
    func_2 = expand(f_2).evalf(subs = subs)
    func_mat = np.array([[-func_1],
                        [-func_2]
                        ])

    func_jab = jacob_func(f_1, f_2)
    func_jab_inv = mat_inv(func_jab)


    delta = func_jab_inv.dot(func_mat)

    x_value = x_test + delta[0]
    y_value = y_test + delta[1]

    #print("this is jab ", func_jab)
    #print("this is -f(x) ", func_mat)
    #print("this is jab inverse ", func_jab_inv)
    #print("this is x_value ", x_value)
    #print("this is y_value ", y_value)


  # adding condition to check the error of the root and breaks if it is satisfied
    if (abs((x_value - x_test)/x_test) < tol and abs((y_value - y_test)/y_test) < tol):
      print ("root of x = " + str(x_value.item()))
      print ("root of y = " + str(y_value.item()))
      break

    else:
      x_test = x_value.item()     # extracts the value of the array and assigns new value of x and y
      y_test = y_value.item()
      print ("x" + str(x_c) + " = " + str(x_test))
      print ('y' + str(x_c) + " = " + str(y_test))
      x_c += 1
      subs[x] = x_test
      subs[y] = y_test




try:
  newton_raphson_2d(f_1, f_2, x_test, y_test, tol, ite)
except TypeError:
  print("cannot compute the value of estimated error anymore")
except UnboundLocalError:
  print("check you entered the equation correctly.\n common errors include omission of * when multiplying coefficients")



# equations for testing the newton raphson function
#y - 0.5 * (exp((x/2)) + exp((-x/2)))
#(9*x**2) + (25 * y**2) - 225



|# transposing a matrix
#for i in range (len(mat)):
    #for j in range(len(mat[1])):
      #result[j][i] = result[i][j]